// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.0
//   protoc               v5.27.3
// source: omni/v1beta4/types/condition.proto

/* eslint-disable */

export const protobufPackage = "omni.v1beta4";

export interface Condition {
  /** Logical operations */
  and?: AndCondition | undefined;
  or?: OrCondition | undefined;
  not?: NotCondition | undefined;
  /** Conditions */
  tag?: TagCondition | undefined;
  blockchain?: BlockchainCondition | undefined;
}

export interface AndCondition {
  left: Condition | undefined;
  right: Condition | undefined;
}

export interface OrCondition {
  left: Condition | undefined;
  right: Condition | undefined;
}

export interface NotCondition {
  item: Condition | undefined;
}

export interface TagCondition {
  tag: string;
}

export interface BlockchainCondition {
  /**
   * The blockchain as defined by SLIP-044.
   *
   * See: <https://github.com/satoshilabs/slips/blob/master/slip-0044.md>
   */
  blockchain: number;
}

function createBaseCondition(): Condition {
  return {
    and: undefined,
    or: undefined,
    not: undefined,
    tag: undefined,
    blockchain: undefined,
  };
}

export const Condition = {
  fromJSON(object: any): Condition {
    return {
      and: isSet(object.and) ? AndCondition.fromJSON(object.and) : undefined,
      or: isSet(object.or) ? OrCondition.fromJSON(object.or) : undefined,
      not: isSet(object.not) ? NotCondition.fromJSON(object.not) : undefined,
      tag: isSet(object.tag) ? TagCondition.fromJSON(object.tag) : undefined,
      blockchain: isSet(object.blockchain)
        ? BlockchainCondition.fromJSON(object.blockchain)
        : undefined,
    };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.and !== undefined) {
      obj.and = AndCondition.toJSON(message.and);
    }
    if (message.or !== undefined) {
      obj.or = OrCondition.toJSON(message.or);
    }
    if (message.not !== undefined) {
      obj.not = NotCondition.toJSON(message.not);
    }
    if (message.tag !== undefined) {
      obj.tag = TagCondition.toJSON(message.tag);
    }
    if (message.blockchain !== undefined) {
      obj.blockchain = BlockchainCondition.toJSON(message.blockchain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Condition>, I>>(base?: I): Condition {
    return Condition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Condition>, I>>(
    object: I,
  ): Condition {
    const message = createBaseCondition();
    message.and =
      object.and !== undefined && object.and !== null
        ? AndCondition.fromPartial(object.and)
        : undefined;
    message.or =
      object.or !== undefined && object.or !== null
        ? OrCondition.fromPartial(object.or)
        : undefined;
    message.not =
      object.not !== undefined && object.not !== null
        ? NotCondition.fromPartial(object.not)
        : undefined;
    message.tag =
      object.tag !== undefined && object.tag !== null
        ? TagCondition.fromPartial(object.tag)
        : undefined;
    message.blockchain =
      object.blockchain !== undefined && object.blockchain !== null
        ? BlockchainCondition.fromPartial(object.blockchain)
        : undefined;
    return message;
  },
};

function createBaseAndCondition(): AndCondition {
  return { left: undefined, right: undefined };
}

export const AndCondition = {
  fromJSON(object: any): AndCondition {
    return {
      left: isSet(object.left) ? Condition.fromJSON(object.left) : undefined,
      right: isSet(object.right) ? Condition.fromJSON(object.right) : undefined,
    };
  },

  toJSON(message: AndCondition): unknown {
    const obj: any = {};
    if (message.left !== undefined) {
      obj.left = Condition.toJSON(message.left);
    }
    if (message.right !== undefined) {
      obj.right = Condition.toJSON(message.right);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AndCondition>, I>>(
    base?: I,
  ): AndCondition {
    return AndCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AndCondition>, I>>(
    object: I,
  ): AndCondition {
    const message = createBaseAndCondition();
    message.left =
      object.left !== undefined && object.left !== null
        ? Condition.fromPartial(object.left)
        : undefined;
    message.right =
      object.right !== undefined && object.right !== null
        ? Condition.fromPartial(object.right)
        : undefined;
    return message;
  },
};

function createBaseOrCondition(): OrCondition {
  return { left: undefined, right: undefined };
}

export const OrCondition = {
  fromJSON(object: any): OrCondition {
    return {
      left: isSet(object.left) ? Condition.fromJSON(object.left) : undefined,
      right: isSet(object.right) ? Condition.fromJSON(object.right) : undefined,
    };
  },

  toJSON(message: OrCondition): unknown {
    const obj: any = {};
    if (message.left !== undefined) {
      obj.left = Condition.toJSON(message.left);
    }
    if (message.right !== undefined) {
      obj.right = Condition.toJSON(message.right);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrCondition>, I>>(base?: I): OrCondition {
    return OrCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrCondition>, I>>(
    object: I,
  ): OrCondition {
    const message = createBaseOrCondition();
    message.left =
      object.left !== undefined && object.left !== null
        ? Condition.fromPartial(object.left)
        : undefined;
    message.right =
      object.right !== undefined && object.right !== null
        ? Condition.fromPartial(object.right)
        : undefined;
    return message;
  },
};

function createBaseNotCondition(): NotCondition {
  return { item: undefined };
}

export const NotCondition = {
  fromJSON(object: any): NotCondition {
    return {
      item: isSet(object.item) ? Condition.fromJSON(object.item) : undefined,
    };
  },

  toJSON(message: NotCondition): unknown {
    const obj: any = {};
    if (message.item !== undefined) {
      obj.item = Condition.toJSON(message.item);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotCondition>, I>>(
    base?: I,
  ): NotCondition {
    return NotCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotCondition>, I>>(
    object: I,
  ): NotCondition {
    const message = createBaseNotCondition();
    message.item =
      object.item !== undefined && object.item !== null
        ? Condition.fromPartial(object.item)
        : undefined;
    return message;
  },
};

function createBaseTagCondition(): TagCondition {
  return { tag: "" };
}

export const TagCondition = {
  fromJSON(object: any): TagCondition {
    return { tag: isSet(object.tag) ? globalThis.String(object.tag) : "" };
  },

  toJSON(message: TagCondition): unknown {
    const obj: any = {};
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagCondition>, I>>(
    base?: I,
  ): TagCondition {
    return TagCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagCondition>, I>>(
    object: I,
  ): TagCondition {
    const message = createBaseTagCondition();
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseBlockchainCondition(): BlockchainCondition {
  return { blockchain: 0 };
}

export const BlockchainCondition = {
  fromJSON(object: any): BlockchainCondition {
    return {
      blockchain: isSet(object.blockchain)
        ? globalThis.Number(object.blockchain)
        : 0,
    };
  },

  toJSON(message: BlockchainCondition): unknown {
    const obj: any = {};
    if (message.blockchain !== undefined) {
      obj.blockchain = Math.round(message.blockchain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockchainCondition>, I>>(
    base?: I,
  ): BlockchainCondition {
    return BlockchainCondition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockchainCondition>, I>>(
    object: I,
  ): BlockchainCondition {
    const message = createBaseBlockchainCondition();
    message.blockchain = object.blockchain ?? 0;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
